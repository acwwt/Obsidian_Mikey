# NEW B 排序三人组

## 1.快速排序

快速排序的思想是从待排序列中取出一个数作为中间数,将比他小的数都排到这个数的左边,比它大的数排到这个数的右边.

首先我们要先实现交换位置的函数,首先我们需要定义一个边界也就是我们待排序列的开始指向`left` 和末尾指向`right` ,我们先用一个变量`tmp` 存储我们要比较的数值,最后当我们比较完以后,再将这个元素归位,我们有一个循环条件就是开始下标要比末尾下标大,在这个条件下,

如下视频所示:

这个函数实现的是一次的排序,第一次排序完以后我们`left` 左边是比它小的数,右边是比它大的数.

那我们要再对`left` 左边的序列和右边的序列在进行快速排序,以此类推,每做完一次都需要将左右两部分进行快速排序,直到`left=right` 那么这时候就用到了递归.

实现如下:

```python
def partition(li, left, right):
    tmp = li[left]
    while left < right:
         while left < right and li[right] >= tmp: # 从右面找比tmp小的数
             right -= 1          # 往左走一步
         li[left] = li[right]   # 把右边的值写到左边的位置
         while left < right and li[left] <= tmp:  # 从左面找比tmp大的数
             left += 1
         li[right] = li[left]   # 把左边的值写到右边的位置
    li[left] = tmp              # 将tmp归位
    return left

def quick_sort(li, left, right):
    if left < right:
        mid = partition(li, left, right)
        quick_sort(li, left, mid - 1)
        quick_sort(li, mid + 1, right)
    return li
```

对于快速排序,它能很快的排序完成,但是他有一个缺点就是如果待排序列为: `9,8,7,6,5,4,3,2,1` 你取到第一个元素那他右边的都要往左移,就成了`8,7,6,5,4,3,2,1` ,那这个8后面的也都要往左移,那他的时间复杂度就会提高,本来他的时间复杂度是`O(nlogn)` ,这就变成了`O(n^2)` ,解决方法就是第一个元素和后面任意一个元素交换.

## 2.堆排序

要了解堆排序的原理,要先了解树,树是一种常见的数据结构,那么堆就是完全二叉树,什么是完全二叉树.

完全二叉树是由满二叉树而引出来的，若设二叉树的`深度为h`，`除第 h 层外`，`其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)`，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

那么堆又分为大顶堆和小顶堆(或大根堆和小根堆),

性质：

每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。

如下图